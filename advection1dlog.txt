######################################
# Finch Log for: advection1d
######################################
(verbosity = 3)
1.	Set time stepper to Euler-explicit
2.	Building simple line mesh with nx elements, nx=100
3.	Building full grid from mesh data. Types = FV
4.	Building reference element: 1D, order=1, nfaces=2
5.	Initial node setup: 0.2556648254394531
6.	Remove duplicate nodes: 1.1030800342559814
7.	Vertex, face, bdry setup: 0.20641088485717773
8.	Remove duplicate bdry nodes: 0.029909133911132812
9.	Total grid building time: 11.526671886444092
10.	Added mesh with 101 vertices and 100 elements.
11.	Full grid has 101 nodes.
12.	Added variable: u of type: scalar, location: cell
13.	Added callback function: bc1_f
14.	Generated function: genfunction_1
15.	Boundary condition: var=u bid=1 type=flux val=genfunction_1
16.	Boundary condition: var=u bid=2 type=No BC val=0.0
17.	Set time stepper values to dt=0.005, Nsteps=100
18.	Initial condition for u : Union{Float64, GenFunction}[0.0]
19.	Added coefficient a : [1]
20.	Making conservation form for variable(s): Any[:u]
21.	Conservation form, input: ["surface(upwind(a,u))"]
22.	SP expr = Any[:(surface(upwind(a, u)))]
23.	SP insert parameters -> Any[:(surface(upwind(a, u)))]
24.	SP replace symbols -> Any[:((finch_state.ops[5]).op((finch_state.ops[28]).op(SymEngine.Basic[1.0], SymEngine.Basic[_u_1])))]
25.	SP handle callbacks -> Any[:((finch_state.ops[5]).op((finch_state.ops[28]).op(SymEngine.Basic[1.0], SymEngine.Basic[_u_1])))]
26.	SP apply ops -> Any[SymEngine.Basic[conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)*SURFACEINTEGRAL]]
27.	expanded: conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)*SURFACEINTEGRAL
28.	Basic->Expr: conditional(isgreaterthan(1.0_FACENORMAL1_1, 0), 1.0 * CELL1__u_1 * _FACENORMAL1_1, 1.0 * CELL2__u_1 * _FACENORMAL1_1) * SURFACEINTEGRAL
29.	SP sterms = Vector{Vector{SymEngine.Basic}}[[[conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)*SURFACEINTEGRAL]]]
30.	SP LHS = Vector{Vector{SymEngine.Basic}}[[[]]]
31.	SP RHS = Vector{Vector{SymEngine.Basic}}[[[]]]
32.	SP surfLHS = Vector{Vector{SymEngine.Basic}}[[[conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)]]]
33.	SP surfRHS = Vector{Vector{SymEngine.Basic}}[[[]]]
34.	SP NONLINEAR = Vector{Vector{SymEngine.Basic}}[[[]]]
35.	Linearized: Vector{Vector{SymEngine.Basic}}[[[]]] + surface(Vector{Vector{SymEngine.Basic}}[[[conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)]]]) = Vector{Vector{SymEngine.Basic}}[[[]]] + surface(Vector{Vector{SymEngine.Basic}}[[[]]])
36.	flux, before modifying for time: Vector{Vector{SymEngine.Basic}}[[[conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)]]] - Vector{Vector{SymEngine.Basic}}[[[]]]
37.	flux, modified for time stepping: Vector{Vector{SymEngine.Basic}}[[[]]] + Vector{Vector{SymEngine.Basic}}[[[-conditional(isgreaterthan(1.0*_FACENORMAL1_1, 0), 1.0*CELL1__u_1*_FACENORMAL1_1, 1.0*CELL2__u_1*_FACENORMAL1_1)]]]
38.	source, before modifying for time: Vector{Vector{SymEngine.Basic}}[[[]]] - Vector{Vector{SymEngine.Basic}}[[[]]]
39.	source, modified for time stepping: Vector{Vector{SymEngine.Basic}}[[[]]] + Vector{Vector{SymEngine.Basic}}[[[]]]
40.	lhs symexpression:
	Any[Any[Any[]]]
41.	rhs symexpression:
	Any[Any[Any[]]]
42.	lhs surface symexpression:
	Any[Any[Any[]]]
43.	rhs surface symexpression:
	Any[Any[Any[SymExpression(:(-(conditional_function(1.0 * FACENORMAL1_1 > 0, 1.0 * CELL1u_1 * FACENORMAL1_1, 1.0 * CELL2u_1 * FACENORMAL1_1))), Any[FACENORMAL1_1, CELL1u_1, FACENORMAL1_1, CELL2u_1, FACENORMAL1_1])]]]
44.	Latex equation:
		Latex equation:
		$ \int_{K}\left[\left[\right]\right] dx + \int_{\partial K}\left[\left[\right]\right] ds = \int_{K}\left[\left[\right]\right] dx + \int_{\partial K}\left[\left[-\left(conditional\left(>\left(1.0 * normal_{1}, 0\right), 1.0 * u_{1+} * normal_{1}, 1.0 * u_{1-} * normal_{1}\right)\right)\right]\right] ds
45.	Conservation form IR: block:
├─ TIMER
│  ├─ allocate
│  └─ block:allocation
│     ├─ (comment)Allocate global vectors.
│     ├─ =
│     │  ├─ global_vector
│     │  └─ Allocate{CustomFloat}
│     │     └─ fv_dofs_partition
│     ├─ =
│     │  ├─ global_solution
│     │  └─ Allocate{CustomFloat}
│     │     └─ fv_dofs_global
│     ├─ =
│     │  ├─ solution
│     │  └─ Allocate{CustomFloat}
│     │     └─ fv_dofs_partition
│     ├─ (comment)Allocate elemental source and flux.
│     ├─ =
│     │  ├─ source
│     │  └─ Allocate{CustomFloat}
│     │     └─ dofs_per_loop
│     ├─ =
│     │  ├─ flux
│     │  └─ Allocate{CustomFloat}
│     │     └─ dofs_per_loop
│     ├─ =
│     │  ├─ flux_tmp
│     │  └─ Allocate{CustomFloat}
│     │     └─ dofs_per_loop
│     ├─ (comment)Boundary done flag for each face.
│     ├─ =
│     │  ├─ bdry_done
│     │  └─ Allocate{CustomInt}
│     │     └─ num_faces
│     ├─ (comment)Flux done flag for each face so that it is not done twice.
│     ├─ =
│     │  ├─ face_flux_done
│     │  └─ Allocate{Bool}
│     │     └─ num_faces
│     ├─ (comment)No indexed variables
│     └─ =
│        ├─ index_values
│        └─ Allocate{CustomInt}
│           └─ 0
└─ block:
   ├─ (comment)No parent-child mesh needed
   ├─ if
   │  ├─ >
   │  │  ├─ num_partitions
   │  │  └─ 1
   │  ├─ block:
   │  │  └─ GHOST_EXCHANGE_FV
   │  │     └─ 0
   │  └─ nothing
   ├─ GATHER_VARS
   │  └─ solution
   ├─ =
   │  ├─ t
   │  └─ 0.0
   ├─ =
   │  ├─ dt
   │  └─ time_stepper
   │     └─ dt
   ├─ (comment)###############################################
   ├─ (comment)Time stepping loop
   └─ TIMER
      ├─ time_steps
      └─ block:
         ├─ block:
         │  ├─ =
         │  │  ├─ last_minor_progress
         │  │  └─ 0
         │  ├─ =
         │  │  ├─ last_major_progress
         │  │  └─ 0
         │  └─ if
         │     ├─ ==
         │     │  ├─ proc_rank
         │     │  └─ 0
         │     ├─ block:
         │     │  └─ PRINT_STRING
         │     │     └─ "Time step progress(%) 0"
         │     └─ nothing
         └─ Loop{ti=1, time_stepper.Nsteps}
            └─ block:
               ├─ FILL_ARRAY
               │  ├─ bdry_done
               │  ├─ 0
               │  └─ num_faces
               ├─ FILL_ARRAY
               │  ├─ face_flux_done
               │  ├─ false
               │  └─ num_faces
               ├─ =
               │  ├─ next_nonzero_index
               │  └─ 1
               ├─ if
               │  ├─ >
               │  │  ├─ num_partitions
               │  │  └─ 1
               │  ├─ block:
               │  │  └─ GHOST_EXCHANGE_FV
               │  └─ nothing
               ├─ (comment)No pre-step function specified
               ├─ TIMER
               │  ├─ step_assembly
               │  └─ block:assembly loop
               │     └─ Loop{ei=1, num_elements}
               │        └─ block:assembly
               │           ├─ =
               │           │  ├─ eid
               │           │  └─ mesh
               │           │     └─ elemental_order
               │           │        └─ ei
               │           ├─ =
               │           │  ├─ index_offset
               │           │  └─ 0
               │           ├─ (comment)Begin assembly code
               │           ├─ =
               │           │  ├─ source
               │           │  │  └─ 1
               │           │  └─ 0.0
               │           ├─ =
               │           │  ├─ flux
               │           │  │  └─ 1
               │           │  └─ 0.0
               │           ├─ block:volume integral
               │           │  ├─ block:volume coefficients
               │           │  │  ├─ (comment)Evaluate volume coefficients.
               │           │  │  └─ =
               │           │  │     ├─ volume
               │           │  │     └─ geometric_factors
               │           │  │        └─ volume
               │           │  │           └─ eid
               │           │  └─ (comment)Compute source terms (volume integral)
               │           ├─ block:surface integral
               │           │  ├─ (comment)Compute flux terms (surface integral) in a face loop
               │           │  └─ Loop{fi=1, faces_per_element}
               │           │     └─ block:
               │           │        ├─ =
               │           │        │  ├─ flux_tmp
               │           │        │  │  └─ 1
               │           │        │  └─ 0.0
               │           │        ├─ (comment)
               │           │        ├─ =
               │           │        │  ├─ fid
               │           │        │  └─ mesh
               │           │        │     └─ element2face
               │           │        │        ├─ fi
               │           │        │        └─ eid
               │           │        ├─ =
               │           │        │  ├─ fbid
               │           │        │  └─ mesh
               │           │        │     └─ facebid
               │           │        │        └─ fid
               │           │        ├─ =
               │           │        │  ├─ left_el
               │           │        │  └─ mesh
               │           │        │     └─ face2element
               │           │        │        ├─ 1
               │           │        │        └─ fid
               │           │        ├─ =
               │           │        │  ├─ right_el
               │           │        │  └─ mesh
               │           │        │     └─ face2element
               │           │        │        ├─ 2
               │           │        │        └─ fid
               │           │        ├─ =
               │           │        │  ├─ neighbor
               │           │        │  └─ left_el
               │           │        ├─ =
               │           │        │  ├─ out_side
               │           │        │  └─ 1
               │           │        ├─ if
               │           │        │  ├─ &&
               │           │        │  │  ├─ ==
               │           │        │  │  │  ├─ eid
               │           │        │  │  │  └─ left_el
               │           │        │  │  └─ >
               │           │        │  │     ├─ right_el
               │           │        │  │     └─ 0
               │           │        │  ├─ block:
               │           │        │  │  ├─ =
               │           │        │  │  │  ├─ neighbor
               │           │        │  │  │  └─ right_el
               │           │        │  │  └─ =
               │           │        │  │     ├─ out_side
               │           │        │  │     └─ 2
               │           │        │  └─ nothing
               │           │        ├─ block:surface coefficients
               │           │        │  ├─ (comment)Evaluate surface coefficients.
               │           │        │  ├─ if/else
               │           │        │  │  ├─ ==
               │           │        │  │  │  ├─ eid
               │           │        │  │  │  └─ left_el
               │           │        │  │  ├─ block:
               │           │        │  │  │  ├─ =
               │           │        │  │  │  │  ├─ normal_sign
               │           │        │  │  │  │  └─ 1
               │           │        │  │  │  └─ =
               │           │        │  │  │     ├─ in_side
               │           │        │  │  │     └─ 1
               │           │        │  │  └─ block:
               │           │        │  │     ├─ =
               │           │        │  │     │  ├─ normal_sign
               │           │        │  │     │  └─ -1
               │           │        │  │     └─ =
               │           │        │  │        ├─ in_side
               │           │        │  │        └─ 2
               │           │        │  ├─ =
               │           │        │  │  ├─ FACENORMAL1_1
               │           │        │  │  └─ *
               │           │        │  │     ├─ normal_sign
               │           │        │  │     └─ mesh
               │           │        │  │        └─ facenormals
               │           │        │  │           ├─ 1
               │           │        │  │           └─ fid
               │           │        │  ├─ =
               │           │        │  │  ├─ FACENORMAL2_1
               │           │        │  │  └─ -
               │           │        │  │     └─ FACENORMAL1_1
               │           │        │  ├─ =
               │           │        │  │  ├─ value_CELL1_u_1
               │           │        │  │  └─ KNOWN_VAR
               │           │        │  │     ├─ 1
               │           │        │  │     ├─ 1
               │           │        │  │     └─ eid
               │           │        │  ├─ =
               │           │        │  │  ├─ value_CELL2_u_1
               │           │        │  │  └─ KNOWN_VAR
               │           │        │  │     ├─ 1
               │           │        │  │     ├─ 1
               │           │        │  │     └─ neighbor
               │           │        │  ├─ =
               │           │        │  │  ├─ area
               │           │        │  │  └─ geometric_factors
               │           │        │  │     └─ area
               │           │        │  │        └─ fid
               │           │        │  └─ =
               │           │        │     ├─ area_over_volume
               │           │        │     └─ /
               │           │        │        ├─ area
               │           │        │        └─ volume
               │           │        ├─ (comment)Compute flux terms (surface integral)
               │           │        ├─ block:
               │           │        │  └─ =
               │           │        │     ├─ flux_tmp
               │           │        │     │  └─ 1
               │           │        │     └─ -
               │           │        │        └─ conditional_function
               │           │        │           ├─ >
               │           │        │           │  ├─ *
               │           │        │           │  │  ├─ 1.0
               │           │        │           │  │  └─ FACENORMAL1_1
               │           │        │           │  └─ 0
               │           │        │           ├─ *
               │           │        │           │  ├─ 1.0
               │           │        │           │  ├─ value_CELL1_u_1
               │           │        │           │  └─ FACENORMAL1_1
               │           │        │           └─ *
               │           │        │              ├─ 1.0
               │           │        │              ├─ value_CELL2_u_1
               │           │        │              └─ FACENORMAL1_1
               │           │        ├─ block:boundary conditions
               │           │        │  ├─ (comment)Apply boundary conditions
               │           │        │  └─ if
               │           │        │     ├─ >
               │           │        │     │  ├─ fbid
               │           │        │     │  └─ 0
               │           │        │     ├─ block:
               │           │        │     │  └─ apply_boundary_conditions_face_rhs
               │           │        │     │     ├─ var
               │           │        │     │     ├─ eid
               │           │        │     │     ├─ fid
               │           │        │     │     ├─ fbid
               │           │        │     │     ├─ mesh
               │           │        │     │     ├─ refel
               │           │        │     │     ├─ geometric_factors
               │           │        │     │     ├─ fv_info
               │           │        │     │     ├─ prob
               │           │        │     │     ├─ t
               │           │        │     │     ├─ dt
               │           │        │     │     ├─ flux_tmp
               │           │        │     │     ├─ bdry_done
               │           │        │     │     ├─ index_offset
               │           │        │     │     └─ index_values
               │           │        │     └─ nothing
               │           │        └─ =
               │           │           ├─ flux
               │           │           │  └─ 1
               │           │           └─ +
               │           │              ├─ flux
               │           │              │  └─ 1
               │           │              └─ *
               │           │                 ├─ flux_tmp
               │           │                 │  └─ 1
               │           │                 └─ area_over_volume
               │           └─ block:local to global
               │              ├─ (comment)Place elemental parts in global system.
               │              └─ block:
               │                 └─ =
               │                    ├─ global_vector
               │                    │  └─ eid
               │                    └─ +
               │                       ├─ source
               │                       │  └─ 1
               │                       └─ flux
               │                          └─ 1
               ├─ TIMER
               │  ├─ update_sol
               │  └─ Loop{update_i=1, fv_dofs_partition}
               │     └─ block:
               │        └─ =
               │           ├─ solution
               │           │  └─ update_i
               │           └─ +
               │              ├─ solution
               │              │  └─ update_i
               │              └─ *
               │                 ├─ dt
               │                 └─ global_vector
               │                    └─ update_i
               ├─ BDRY_TO_VECTOR
               │  └─ solution
               ├─ SCATTER_VARS
               │  └─ solution
               ├─ (comment)No post-step function specified
               ├─ =
               │  ├─ t
               │  └─ +
               │     ├─ t
               │     └─ dt
               └─ block:
                  └─ if/else
                     ├─ >=
                     │  ├─ *
                     │  │  ├─ 100.0
                     │  │  └─ /
                     │  │     ├─ ti
                     │  │     └─ time_stepper
                     │  │        └─ Nsteps
                     │  └─ +
                     │     ├─ last_major_progress
                     │     └─ 10
                     ├─ block:
                     │  ├─ =
                     │  │  ├─ last_major_progress
                     │  │  └─ +
                     │  │     ├─ last_major_progress
                     │  │     └─ 10
                     │  ├─ =
                     │  │  ├─ last_minor_progress
                     │  │  └─ +
                     │  │     ├─ last_minor_progress
                     │  │     └─ 2
                     │  └─ if
                     │     ├─ ==
                     │     │  ├─ proc_rank
                     │     │  └─ 0
                     │     ├─ block:
                     │     │  └─ PRINT_STRING
                     │     │     └─ last_major_progress
                     │     └─ nothing
                     └─ block:
                        └─ if
                           ├─ >=
                           │  ├─ *
                           │  │  ├─ 100.0
                           │  │  └─ /
                           │  │     ├─ ti
                           │  │     └─ time_stepper
                           │  │        └─ Nsteps
                           │  └─ +
                           │     ├─ last_minor_progress
                           │     └─ 2
                           ├─ block:
                           │  ├─ =
                           │  │  ├─ last_minor_progress
                           │  │  └─ +
                           │  │     ├─ last_minor_progress
                           │  │     └─ 2
                           │  └─ if
                           │     ├─ ==
                           │     │  ├─ proc_rank
                           │     │  └─ 0
                           │     ├─ block:
                           │     │  └─ PRINT_STRING
                           │     │     └─ "."
                           │     └─ nothing
                           └─ nothing

46.	Code layer: 
function generated_solve_function_for_u(var::Vector{Variable{FT}}, mesh::Grid, refel::Refel, geometric_factors::GeometricFactors, fv_info::FVInfo, config::FinchConfig, coefficients::Vector{Coefficient}, variables::Vector{Variable{FT}}, test_functions::Vector{Coefficient}, ordered_indexers::Vector{Indexer}, prob::FinchProblem, time_stepper::Stepper, buffers::ParallelBuffers, timer_output::TimerOutput, nl_var=nothing) where FT<:AbstractFloat
    
    # User specified data types for int and float
    # int type is Int64
    # float type is Float64
    
    # pre/post step functions if defined
    pre_step_function = prob.pre_step_function;
    post_step_function = prob.post_step_function;
    
    
    
    # Prepare some useful numbers
    # dofs_per_node = 1;
    # dofs_per_loop = 1;
    # dof_offsets = [0];
    
    varcount = length(var);
    dofs_per_node = var[1].total_components;
    dofs_per_loop = length(var[1].symvar);
    dof_offsets = zeros(Int, varcount);
    for i=2:varcount
        dof_offsets[i] = dofs_per_node;
        dofs_per_node += var[i].total_components;
        dofs_per_loop += length(var[i].symvar);
    end

    
    nnodes_partition = size(mesh.allnodes,2);
    nnodes_global = nnodes_partition;
    num_elements = mesh.nel_owned;
    num_elements_global = mesh.nel_global;
    num_elements_ghost = mesh.nel_ghost;
    num_faces = mesh.nface_owned + mesh.nface_ghost;
    
    dofs_global = dofs_per_node * nnodes_global;
    fv_dofs_global = dofs_per_node * num_elements_global;
    dofs_partition = dofs_per_node * nnodes_partition;
    fv_dofs_partition = dofs_per_node * (num_elements + num_elements_ghost);
    num_partitions = config.num_partitions;
    proc_rank = config.proc_rank;
    
    nodes_per_element = refel.Np;
    qnodes_per_element = refel.Nqp;
    faces_per_element = refel.Nfaces;
    nodes_per_face = refel.Nfp[1];
    dofs_per_element = dofs_per_node * nodes_per_element;
    local_system_size = dofs_per_loop * nodes_per_element;
    
    num_bdry_faces = 0;
    nbids = length(mesh.bids);
    for bi=1:nbids
        num_bdry_faces += length(mesh.bdryface[bi]);
    end

    
    
    # FVM specific pieces
    dofs_global = fv_dofs_global;
    # boundary values for flux on each boundary face
    boundary_flux = zeros(Float64, num_bdry_faces * dofs_per_node);
    boundary_dof_index = zeros(Int64, num_bdry_faces * dofs_per_node);
    
    @timeit timer_output "allocate" begin
        #= Allocate global vectors. =#
        global_vector::Vector{Float64} = zeros(Float64, fv_dofs_partition)
        global_solution::Vector{Float64} = zeros(Float64, fv_dofs_global)
        solution::Vector{Float64} = zeros(Float64, fv_dofs_partition)
        #= Allocate elemental source and flux. =#
        source::Vector{Float64} = zeros(Float64, dofs_per_loop)
        flux::Vector{Float64} = zeros(Float64, dofs_per_loop)
        flux_tmp::Vector{Float64} = zeros(Float64, dofs_per_loop)
        #= Boundary done flag for each face. =#
        bdry_done::Vector{Int64} = zeros(Int64, num_faces)
        #= Flux done flag for each face so that it is not done twice. =#
        face_flux_done::Vector{Bool} = zeros(Bool, num_faces)
        #= No indexed variables =#
        index_values::Vector{Int64} = zeros(Int64, 0)
        
    end # timer:allocate

    @timeit timer_output "GPU alloc" begin
        # Allocate and transfer things to the GPU
        mesh_elemental_order_gpu = CuArray(mesh.elemental_order);
        geometric_factors_volume_gpu = CuArray(geometric_factors.volume);
        mesh_element2face_gpu = CuArray(mesh.element2face);
        mesh_facebid_gpu = CuArray(mesh.facebid);
        mesh_face2element_gpu = CuArray(mesh.face2element);
        mesh_facenormals_gpu = CuArray(mesh.facenormals);
        variables_1_values_gpu = CuArray(variables[1].values);
        geometric_factors_area_gpu = CuArray(geometric_factors.area);
        global_vector_gpu = CuArray(global_vector);
        
        index_ranges = CuArray(tmp_index_ranges);
    end

    #= No parent-child mesh needed =#
    if (num_partitions > 1)
        exchange_ghosts_fv(var, mesh, dofs_per_node, 0, config);
    end

    solution = get_var_vals(var, solution, );
    t = 0.0
    dt = time_stepper.dt
    #= ############################################### =#
    #= Time stepping loop =#
    @timeit timer_output "time_steps" begin
        last_minor_progress = 0
        last_major_progress = 0
        if (proc_rank == 0)
            print("Time step progress(%) 0")
        end

        for ti = 1:time_stepper.Nsteps
            bdry_done .= 0
            face_flux_done .= false
            next_nonzero_index = 1
            if (num_partitions > 1)
                exchange_ghosts_fv(var, mesh, dofs_per_node, ti, config);
            end

            #= No pre-step function specified =#
            @timeit timer_output "step_assembly" begin
                
                
                # Send needed values back to gpu
                copyto!(variables_1_values_gpu, variables[1].values);
                CUDA.synchronize();
                
                
                # This is done on gpu
                @cuda threads=256 blocks=min(4096,ceil(Int, dofs_global/256)) gpu_assembly_kernel(mesh_elemental_order_gpu, geometric_factors_volume_gpu, mesh_element2face_gpu, mesh_facebid_gpu, mesh_face2element_gpu, 
                            mesh_facenormals_gpu, variables_1_values_gpu, geometric_factors_area_gpu, global_vector_gpu, dofs_global, 
                            faces_per_element, index_ranges)
                
                
                # Asynchronously compute boundary values on cpu
                @timeit timer_output "bdry_vals" begin
                    next_bdry_index = 1;
                    for bi=1:nbids
                        nfaces = length(mesh.bdryface[bi]);
                        for fi=1:nfaces
                            fid = mesh.bdryface[bi][fi];
                            eid = mesh.face2element[1,fid];
                            fbid = mesh.bids[bi];
                            volume = geometric_factors.volume[eid]
                            area = geometric_factors.area[fid]
                            area_over_volume = (area / volume)
                            
                            
                            
                            index_offset = 0
                            
                            row_index = index_offset + 1 + dofs_per_node * (eid - 1);
                            
                            apply_boundary_conditions_face_rhs(var, eid, fid, fbid, mesh, refel, geometric_factors, fv_info, prob, 
                                                                t, dt, flux_tmp, bdry_done, index_offset, index_values)
                            #
                            # store it
                            boundary_flux[next_bdry_index] = flux_tmp[1] * area_over_volume;
                            boundary_dof_index[next_bdry_index] = row_index;
                            next_bdry_index += 1;
                            
                        end

                    end

                end # timer bdry_vals

                
                # Then get global_vector from gpu
                CUDA.synchronize()
                copyto!(global_vector, global_vector_gpu)
                CUDA.synchronize()
                
                # And add BCs to global vector
                for update_i = 1:(num_bdry_faces * dofs_per_node)
                    row_index = boundary_dof_index[update_i]
                    global_vector[row_index] = global_vector[row_index] + boundary_flux[update_i];
                end

                
                
            end # timer:step_assembly

            
            @timeit timer_output "update_sol" begin
                for update_i = 1:fv_dofs_partition
                    solution[update_i] = (solution[update_i] + (dt * global_vector[update_i]))
                end

                
            end # timer:update_sol

            
            copy_bdry_vals_to_vector(var, solution, mesh, dofs_per_node, prob);
            place_vector_in_vars(var, solution);
            #= No post-step function specified =#
            t = (t + dt)
            if ((100.0 * (ti / time_stepper.Nsteps)) >= (last_major_progress + 10))
                last_major_progress = (last_major_progress + 10)
                last_minor_progress = (last_minor_progress + 2)
                if (proc_rank == 0)
                    print(string(last_major_progress))
                end

            
            else
                if ((100.0 * (ti / time_stepper.Nsteps)) >= (last_minor_progress + 2))
                    last_minor_progress = (last_minor_progress + 2)
                    if (proc_rank == 0)
                        print(".")
                    end

                end

            end

        end

        
    end # timer:time_steps

    
    
    return nothing;
    
end # function



47.	Generated function: generated_solve_function_for_u(var::Vector{Variable{FT}}, mesh::Grid, refel::Refel, geometric_factors::GeometricFactors, fv_info::FVInfo, config::FinchConfig, coefficients::Vector{Coefficient}, variables::Vector{Variable{FT}}, test_functions::Vector{Coefficient}, ordered_indexers::Vector{Indexer}, prob::FinchProblem, time_stepper::Stepper, buffers::ParallelBuffers, timer_output::TimerOutput, nl_var = nothing)
48.	Generated function: generated_solve_function_for_u(var::Vector{Variable{FT}}, mesh::Grid, refel::Refel, geometric_factors::GeometricFactors, fv_info::FVInfo, config::FinchConfig, coefficients::Vector{Coefficient}, variables::Vector{Variable{FT}}, test_functions::Vector{Coefficient}, ordered_indexers::Vector{Indexer}, prob::FinchProblem, time_stepper::Stepper, buffers::ParallelBuffers, timer_output::TimerOutput, nl_var = nothing)
49.	Imported code from finch-gpu-test/fvad1dgpucode-newkernel.jl
50.	Built initial conditions for: u
51.	Indexed variables detected, but no assembly loops specified. Using default.
52.	Solved for [u]
53.	Closed generated code files.
54.	 ────────────────────────────────────────────────────────────────────────────────
                                        Time                    Allocations      
                               ───────────────────────   ────────────────────────
       Tot / % measured:            96.9s /  60.1%           4.69GiB /  34.7%    

 Section               ncalls     time    %tot     avg     alloc    %tot      avg
 ────────────────────────────────────────────────────────────────────────────────
 Mesh                       1    23.9s   41.0%   23.9s    389MiB   23.3%   389MiB
   mesh2grid                1    11.6s   19.9%   11.6s    223MiB   13.4%   223MiB
   gen/read                 1    230ms    0.4%   230ms   3.88MiB    0.2%  3.88MiB
   geo factors              1    151ms    0.3%   151ms   4.78MiB    0.3%  4.78MiB
     fv_info                1   93.7ms    0.2%  93.7ms   3.96MiB    0.2%  3.96MiB
   bids                     1   70.4ms    0.1%  70.4ms   2.85MiB    0.2%  2.85MiB
 CodeGen                    1    19.7s   33.8%   19.7s    489MiB   29.3%   489MiB
 Solve                      1    14.7s   25.2%   14.7s    791MiB   47.4%   791MiB
   FV_solve                 1    14.2s   24.4%   14.2s    760MiB   45.5%   760MiB
     GPU alloc              1    7.30s   12.5%   7.30s    398MiB   23.8%   398MiB
     time_steps             1    2.71s    4.6%   2.71s    152MiB    9.1%   152MiB
       step_assembly      100    2.51s    4.3%  25.1ms    146MiB    8.7%  1.46MiB
         bdry_vals        100    988ms    1.7%  9.88ms   54.4MiB    3.3%   557KiB
       update_sol         100    190ms    0.3%  1.90ms   5.77MiB    0.3%  59.0KiB
     allocate               1   3.29μs    0.0%  3.29μs   3.91KiB    0.0%  3.91KiB
 ────────────────────────────────────────────────────────────────────────────────

55.	Completed. Closing Log.
